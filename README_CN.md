bsdb是一种新型的只读KV数据库。

#### 什么是只读数据库？

 只读数据库在线只支持查询操作，不支持对记录进行动态插入和修改。数据库中的数据需要通过一个离线的过程来构建，构建完成后才可以上线提供在线查询服务。

#### 不能在线修改的数据库有什么用？

- 一种传统场景是需要随系统/软件发布的预置字典表，这些数据只有在系统/软件升级的时候才有可能需要更新。

- 更多场景则是大数据系统对数据加工后，通常需要对外提供数据查询服务；这些查询服务的支撑数据通常对更新的时效性要求不是特别高，很多时候是批量定时更新的，但每次更新都要替换大量的记录（几千万到几百亿），接近于整库/表全量替换。作为在线查询到数据服务，通常要支持很高qps的查询量，同时还得保证查询的响应时间比较低且确定，尽量不要有慢查询。利用传统KV数据库来支撑这种场景，最常碰到的一个问题就是定时对数据进行批量更新的时候，查询服务的SLA难以保证，通常需要降低更新操作的速率，这又导致更新耗时非常长；另一个常见问题则是通常需要配置/维护昂贵的数据库集群才能支持查询服务的SLA。

#### 只读数据库有什么优势？
- 简单可靠。构建时磁盘IO可以全部优化为大块顺序写，机械硬盘和对象存储也可以支撑; 对SSD也很友好，近乎0写入放大，有利于优化SSD寿命，甚至可以考虑利用廉价的消费级SSD。在线程序逻辑简单, 不需要支持事务/锁/日志/集群; 运行时数据只读，不用担心破坏数据完整性。
- 高性能。在构建的阶段可以看到全量数据，可以充分利用数据的信息来优化数据的组织形式以利于查询。在线查询阶段，不同的读查询互相不需要任何信息共享，易于并发处理。
- 低时延。读路径短，且IO没有干扰，有利于保持高的吞吐量和稳定的时延。
- 可扩展。通过简单复制来启动多个实例，达到真正无性能损失的无限线性扩展。

#### 存储结构设计
BSDB是一种KV数据库，核心由配置文件，数据文件和索引文件构成。KV记录保存在数据文件里，索引文件则记录了某个Key对应的记录在数据文件内的位置，而配置文件中记录构建时的参数和数据库的统计信息。

##### 索引文件
BSDB的记录寻址由两级索引来完成。第一级索引为一个完美Hash函数，该函数会将输入的Key映射为一个整数，通过这个整数可以在第二级索引里对应的位置找到该Key对应的记录在数据文件内的地址。

完美Hash函数通过传入数据集的全量的Key来构建，构建完成后，可以生成一个函数，将N个Key映射为范围为1-N的整数，且不同的Key会映射到不同的数字。但当输入数据库中不存在的Key时，Hash函数可能会错误返回一个数字，此时就需要通过索引读取数据文件中保存的记录信息进行比对，才可以发现输入的Key在数据集中不存在;针对这个问题，可以预先保存Key的checksum，通过checksum比对可以提前发现这种情况，从而减少一部分磁盘的读需求。不同的checksum长度对应的false positive rate如下：

|checksum bits                          |false positive ratio |
|-------------------------------|-----------------------------|
|2            |12.5%            |
|4            |6.2%            |
|8            |0.39%           |
|10            |0.097%           |
|12            |0.025%           |
完美Hash函数运行时需要加载到内存，其大小为：记录数 x ((3+checksum) / 8) 字节。对于一个100亿的数据集，checksum选择5，则完美Hash函数需要接近10GB的HEAP内存。

第二级索引为一个基于磁盘的地址数组，每个地址预留的长度为8字节，因此第二级索引的大小为：记录数 x 8 字节。对于100亿记录的数据集，二级索引文件大概是80GB。二级索引文件运行时不需要加载到内存;如果系统的可用内存大于或者接近二级索引文件大小，则利用Buffered IO来读取索引文件，可以利用操作系统的页面缓存来加速;不过如果系统内存较小，则更适合利用Direct模式跳过系统缓存来读取二级索引文件，更有可能获得较高性能。

